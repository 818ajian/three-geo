<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <title>heightmap demo</title>
</head>
<body>
    <h1>(WIP)</h1>
    <canvas id="canvas" style="width: 100%; height: 100%;"></canvas>

    <script src="../simple-viewer/three.min.js"></script>
    <script src="../simple-viewer/stats.min.js"></script>
    <script src="../simple-viewer/OrbitControls.js"></script>

    <!-- <script src="../../dist/three-geo.min.js"></script> -->
    <script src="../../lib/three-geo.js"></script>

    <script>
        'use strict';
        const canvas = document.getElementById("canvas");
        const camera = new THREE.PerspectiveCamera(75, canvas.width/canvas.height, 0.001, 1000);
        camera.position.set(0, 0, 1.5);
        camera.up.set(0, 0, 1); // important for OrbitControls

        const renderer = new THREE.WebGLRenderer({
            // alpha: true,
            canvas: canvas,
        });

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // https://stackoverflow.com/questions/29884485/threejs-canvas-size-based-on-container
        const resizeCanvasToDisplaySize = (force=false) => {
            let width = canvas.clientWidth;
            let height = canvas.clientHeight;

            // adjust displayBuffer size to match
            if (force || canvas.width != width || canvas.height != height) {
                // you must pass false here or three.js sadly fights the browser
                // console.log "resizing: #{canvas.width} #{canvas.height} -> #{width} #{height}"
                renderer.setSize(width, height, false);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
        };
        resizeCanvasToDisplaySize(true); // first time

        // object stuff --------
        const scene = new THREE.Scene();
        const walls = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.BoxBufferGeometry(1, 1, 1)),
            new THREE.LineBasicMaterial({color: 0xcccccc}));
        walls.position.set(0, 0, 0);
        scene.add(walls);
        scene.add(new THREE.AxesHelper(1));

        // render stuff --------
        const stats = new Stats();
        stats.showPanel(1); // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.appendChild(stats.dom);
        const render = () => {
            stats.update();
            resizeCanvasToDisplaySize();
            renderer.render(scene, camera);
        };


        // main --------
        render(); // first time
        controls.addEventListener('change', render);

        const tgeo = new ThreeGeo({
            tokenMapbox: '********', // <---- set your Mapbox API token here
        });

        const isDebug = 0;
        if (isDebug) {
            tgeo.tokenMapbox = '....';
            tgeo.setApiRgb(`../geo-viewer/cache/eiger/mapbox-terrain-rgb`);
            tgeo.setApiSatellite(`../geo-viewer/cache/eiger/mapbox-satellite`);
            // console.log('tgeo:', tgeo);
        }

        const demToObjects = (demUri, demTile, proj) => {
            const {obj, offset, size} = ThreeGeo.bboxToWireframe(
                ThreeGeo.tileToBbox(demTile), proj, {
                    offsetZ: - 0.2,
                    color: 0xcc00cc,
                });
            // console.log('offset, size:', offset, size);

            let _demUri = demUri;
            if (isDebug) {
                const [tx, ty, tz] = demTile;
                // _demUri = `../geo-viewer/cache/eiger/mapbox-terrain-rgb-${tz}-${tx}-${ty}.blob.debug.png`;
                _demUri = `../geo-viewer/cache/eiger/mapbox-terrain-rgb-${tz}-${tx}-${ty}.blob`;
            }

            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(size[0], size[1]),
                new THREE.MeshBasicMaterial({
                    map: new THREE.TextureLoader().load(_demUri),
                    // side: THREE.DoubleSide,
                }));
            plane.position.set(...offset);
            return {
                wireframe: obj,
                plane: plane,
            };
        };

        if (tgeo.tokenMapbox === '********') {
            alert('Please set your Mapbox API token in ThreeGeo constructor.');
        } else {
            // params: [lat, lng], terrain's radius (km), zoom resolution, callbacks
            // Beware the value of radius; radius > 5.0 (km) could trigger huge number of tile API calls!!
            const origin = [46.5763, 7.9904];
            const radius = 5.0;
            const {proj, unitsPerMeter} = tgeo.getProjection(origin, radius);
            // console.log('proj:', proj);
            // console.log('unitsPerMeter:', unitsPerMeter); // (unused here)

            const srcDemUris = {};

            tgeo.getTerrain(origin, radius, 12, {
                onRgbDem: (meshes) => { // your implementation when terrain's geometry is obtained
                    meshes.forEach((mesh) => {
                        console.log('rgb dem mesh:', mesh);
                        scene.add(mesh);

                        //======== how to access mesh's heightmap
                        const array = mesh.geometry.attributes.position.array;
                        // console.log('array:', array);
                        console.log('array.length:', array.length); // 3x128x128 (+ deltaSeams)

                        //======== how to access heightmap (grand-parental tile)
                        console.log('userData:', mesh.userData);
                        const srcDem = mesh.userData.threeGeo.srcDem;
                        const srcDemUri = `${srcDem.uri}${tgeo.tokenMapbox}`;
                        const srcDemTile = srcDem.tile;
                        console.log('srcDemUri:', srcDemUri);

                        if (! srcDemUris[srcDemUri]) {
                            console.log('adding:', srcDemUri);
                            srcDemUris[srcDemUri] = true;

                            const {wireframe, plane} = demToObjects(srcDemUri, srcDemTile, proj);
                            scene.add(wireframe, plane);
                        }

                        //======== how to visualize the corresponding satellite tile's geometry
                        const tile = mesh.userData.threeGeo.tile;
                        scene.add(ThreeGeo.bboxToWireframe(
                            ThreeGeo.tileToBbox(tile), proj, {offsetZ: - 0.1}).obj);
                    });
                    render(); // now render scene after dem meshes are added
                },
                onSatelliteMat: (mesh) => { // your implementation when terrain's satellite texture is obtained
                    const tile = mesh.userData.threeGeo.tile;
                    console.log('tile:', tile);
                    mesh.material.wireframe = true;
                    // mesh.material.wireframe = (tile[0]%2 === tile[1]%2);
                    // mesh.material.side = THREE.DoubleSide;
                    render(); // now render scene after dem material (satellite texture) is applifed
                },
            });
        }
    </script>
</body>
</html>
